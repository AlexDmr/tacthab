var util = require('util'),
	EventEmitter = require('events').EventEmitter,
	http = require("http"),
	url = require("url"),
	// xml2js = require('xml2js'),
	xmldom = require("xmldom");

var xmlSerializer	= new xmldom.XMLSerializer();
var domParser		= new xmldom.DOMParser();
function byteLength(str) {
	// returns the byte length of an utf8 string
	var s = str.length;
	for (var i=str.length-1; i>=0; i--) {
		 var code = str.charCodeAt(i);
		 if (code > 0x7f && code <= 0x7ff) s++;
			else if (code > 0x7ff && code <= 0xffff) s+=2;
		 if (code >= 0xDC00 && code <= 0xDFFF) i--; //trail surrogate
		}
	return s;
}

var TRACE = true;
var DETAIL = false;
/* XXX DEBUG
var UpnpAction = function(desc) {
	this.name = desc.name;
	this.arguments = {};
}
*/

/**
 * A UPnP service.
 *
 * device: the device offering the service
 * desc: an object containing details of the service.
 */
var UpnpService = function(device, desc) {
    EventEmitter.call(this);

	if (TRACE && DETAIL) {
		console.log("creating service object for: " + JSON.stringify(desc)); 
	}

	this.device = device;

	this.serviceType = desc.serviceType[0];
	this.serviceId   = desc.serviceId[0];
	this.controlUrl  = desc.controlURL[0];
	this.eventSubUrl = desc.eventSubURL[0];
	this.scpdUrl     = desc.SCPDURL[0];

	// actions that can be performed on this service
	this.actions = {};

	// variables that represent state on this service.
	this.stateVariables = {};

	var u = url.parse(device.location);
	this.host = u.hostname;
	this.port = u.port;
	
	this.subscriptionTimeout = 300; // 60;
}

util.inherits(UpnpService, EventEmitter);

/**
 * Call an action on a service.
 * args is a java object of name, value pairs. e.g. { BinaryState : v }
 */
UpnpService.prototype.callAction = function(actionName, args, callback) {
	if (TRACE && DETAIL) {
		console.log("calling action : " + actionName + " " + JSON.stringify(args));
	}
	/*
	var argXml = "";
	for (name in args) {
		argXml += "<" + name + ">" + args[name] + "</" + name + ">"; 
	}
	var content =  "<u:" + actionName + " xmlns:u=\""+this.serviceType+"\">" + argXml + "</u:" + actionName + ">";
	*/
	// DEBUG XXX
		var str =  "<u:" + actionName + " xmlns:u=\""+this.serviceType+"\"></u:" + actionName + ">";
		var doc = domParser.parseFromString( str );
		for (var name in args) {
			 var node = doc.createElement(name);
			 node.appendChild( doc.createTextNode(args[name]) );
			 doc.documentElement.appendChild( node );
			}
		// console.log("<DEBUG>\n", new xmldom.XMLSerializer().serializeToString( doc ), "\n</DEBUG>");
	// XXX
	
	
	
	// var s = [SOAP_ENV_PRE, content, SOAP_ENV_POST].join("");
	var s = [SOAP_ENV_PRE, xmlSerializer.serializeToString( doc ), SOAP_ENV_POST].join("");
	// console.log(s.length, '/', byteLength(s));
	// console.log(s);
	var options = {
	  	host    : this.host,
	  	port    : this.port,
	  	path    : this.controlUrl,
	  	method  : "POST",
	}
	if (TRACE && DETAIL) {
		console.log("sending SOAP request " + JSON.stringify(options) + "\n" + s);
	}

	options.headers = {
		"host"           : this.host + ":" + this.port,
		"SOAPACTION"     : "\"" + this.serviceType + "#" + actionName + "\"",
		'Content-Type'   : 'text/xml; charset="utf-8"',
		"content-length" : byteLength(s)//s.length,
	};
	// console.log("_____________________\n\nCall", actionName, "\noptions:", options, "\nheaders:", options.headers, "\n", s, "\n\n_____________________");

	var req = http.request(options, function(res) {
		var buf = "";
		res.on('data', function (chunk) { buf += chunk });
		res.on('end', function () { 
			if (res.statusCode !== 200) {
			  callback(new Error("Invalid SOAP action, code:" + res.statusCode), buf);
			}
			else {
				callback(null, buf)
			}
		});
	});
	req.on('error', function(e) {
		  console.log('problem with callAction: ', e.message);
		});
	req.end(s);
}

UpnpService.prototype.subscribe = function(callback, nbTry) {
	if(typeof nbTry === "undefined") {nbTry = 3;}
	var self = this;
	// TODO determine IP address for service to callback on.
	var callbackUrl = "http://" + this.device.localAddress + ":" + this.device.controlPoint.eventHandler.serverPort + "/listener";
	
	var path;
	if(this.eventSubUrl.indexOf('/') !== 0) {path = '/'; path += this.eventSubUrl;} else {path = this.eventSubUrl;}
	var options = {
	  	method  : "SUBSCRIBE",
	  	host    : this.host,
	  	port    : this.port,
	  	path    : path//this.eventSubUrl,
	}
	options.headers = {
		"HOST"    			: this.host + ":" + this.port,
		"CALLBACK" 			: "<" + callbackUrl + ">",
		"NT"      			: "upnp:event",
		"TIMEOUT"			: "Second-" + this.subscriptionTimeout,
		"Content-Length"	: 0
	};
	
	if (TRACE && DETAIL) {
		console.log("subscribing: " + JSON.stringify(options));
	}
	
	var req = http.request(options, function(res) {
		var buf = "";
		res.on('data', function (chunk) { buf += chunk });
		res.on('end', function () {
			if (res.statusCode !== 200) {
			  //callback(new Error("Problem with subscription on " + service.serviceId + " status HTTP " + res.statusCode), buf);
			  console.error( "Problem with subscription on device", self.device.friendlyName, "service", self.serviceId, " status HTTP ", res.statusCode, buf);
			  if(nbTry) {
				 console.error( "Retry in ", 2*(4-nbTry), "seconds" );
				 setTimeout	( function() {self.subscribe(callback, nbTry-1);}
							, 2000 * (4-nbTry) 
							);
				} else {console.log( JSON.stringify(options) );}
			}
			else {
				if (TRACE && DETAIL) {
					 console.log("got subscription response: " + JSON.stringify(res.headers.sid));
					}
				var sid = res.headers.sid;
				var subscription = new Subscription(self, sid, self.subscriptionTimeout);
				self.device.controlPoint.eventHandler.addSubscription(subscription);

				callback(null, buf)
			} 
		});
	});
	req.on('error', function(e) {
		  console.log('problem with subscribe: ', e.message);
		});
	req.end();
}

/**
 * 
 */
UpnpService.prototype._resubscribe = function(sid, callback) {
	var self = this;
	var options = {
	  	method  : "SUBSCRIBE",
	  	host    : this.host,
	  	port    : this.port,
	  	path    : this.eventSubUrl,
	}
	options.headers = {
		"host"     : this.host + ":" + this.port,
		"sid"      : sid,
		"timeout"  : "Second-" + this.subscriptionTimeout,
	};
	
	var req = http.request(options, function(res) {
		var buf = "";
		res.on('data', function (chunk) { buf += chunk });
		res.on('end', function () { 
			if (res.statusCode !== 200) {
				console.error("Problem with re-subscription on " + sid + " : " + buf);
				callback(new Error("Problem with re-subscription on " + sid), buf);
			}
			else {
				if (TRACE && DETAIL) {
					 console.log("re-subscription success: " + self.device.udn + " : " + self.serviceId);
					}
				callback(null, buf);
			} 
		});
	});
	req.on('error', function(e) {
		  console.log('problem with _resubscribe: ', e.message);
		});
	req.end("");
}

/**
 * 
 */
UpnpService.prototype.unsubscribe = function(sid, callback) {
	var self = this;
	var options = {
	  	method  : "UNSUBSCRIBE",
	  	host    : this.host,
	  	port    : this.port,
	  	path    : this.eventSubUrl,
	}
	options.headers = {
		"host"     : this.host + ":" + this.port,
		"sid"      : sid,
	};

	var req = http.request(options, function(res) {
		var buf = "";
		res.on('data', function (chunk) { buf += chunk });
		res.on('end', function () { 
			if (res.statusCode !== 200) {
				if (callback && typeof(callback) === "function") {
					callback(new Error("Problem with unsubscription on " + self.serviceId), buf);
				}
			}
			else {
				if (TRACE && DETAIL) {console.log("unsubscribe success: " + buf);}
				if (callback && typeof(callback) === "function") {
					callback(null, buf);
				}
			} 
		});
	});
	req.on('error', function(e) {
		  console.log('problem with unsubscribe: ', e.message);
		});
	req.end("");
}

/**
 * 
 */
UpnpService.prototype._getServiceDesc = function(callback) {
	var self = this;
	var options = {
		host : this.host,
		port : this.port,
		path : this.scpdUrl,
	}
	options.headers = {
		"host"  : this.host + ":" + this.port,
	};
	var req = http.request(options, function(res) {
		var buf = "";
		res.on('data', function (chunk) { buf += chunk });
		res.on('end', function () { 
			if (res.statusCode !== 200) {
				callback(new Error("Problem with getting basic event service desc " + self.serviceId), buf);
			}
			else {
				// TODO handle actions and state variables
				callback(null, buf);
			} 
		});
	});
	req.on('error', function(e) {
		  console.log('problem with _getServiceDesc: ', e.message);
		});
	req.end("");
}

/**
 * A subscription
 */
var Subscription = function(service, sid, timeout) {
	var self = this;
	this.service = service;
	this.sid = sid;		// subscrioption id
	this.timeout = timeout;	// timeout in seconds
	
	this.timer = setTimeout(function() { 
		self._resubscribe();
	}, (this.timeout*1000)-5000);
}

Subscription.prototype._resubscribe = function() {
	var self = this;
	this.service._resubscribe(this.sid, function(err, buf) {
		if (err) {
			console.error("ERROR:  problem re-subscribing: " + err + "\n" + buf);
			// remove from eventhandler
			self.service.device.controlPoint.eventHandler.removeSubscription(self);
			clearTimeout(self.timer);
			
			// TODO maybe try a new subscription ???
		}
		else {
			// cool
			self.timer = setTimeout(function() { 
				self._resubscribe();
			}, (self.timeout*1000)-5000);
		}
	});
}

Subscription.prototype.unsubscribe = function() {
	clearInterval(this.timer);
	this.service.unsubscribe(this.sid);
}

Subscription.prototype.handleEvent = function(event) {
	if (TRACE && DETAIL) {
		console.log("subscription event: " + JSON.stringify(event));
	}
	this.service.emit("stateChange", event);
}

exports.UpnpService = UpnpService;


/* ---------------------------------------------------------------------------------- */
const SOAP_ENV_PRE = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<s:Envelope \
xmlns:s=\"http://schemas.xmlsoap.org/soap/envelope/\" \
s:encodingStyle=\"http://schemas.xmlsoap.org/soap/encoding/\">\n<s:Body>\n";

const SOAP_ENV_POST = "</s:Body>\n</s:Envelope>";


